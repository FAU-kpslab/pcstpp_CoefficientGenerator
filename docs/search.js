window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "coefficientFunction", "modulename": "coefficientFunction", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "coefficientFunction.CoefficientFunction", "modulename": "coefficientFunction", "qualname": "CoefficientFunction", "kind": "class", "doc": "<p>CoefficientFunction(sequence, function)</p>\n\n<p>A class used to define the coefficient functions f(ell; m), encoded by a tuple m denoting the operator sequence.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>sequence</strong> (Tuple[Tuple[int,...],...]):\nThe operator sequence m identifying the function f(ell; m).</li>\n<li><strong>function</strong> (QuasiPolynomial):\nThe corresponding coefficient function f(ell; m).</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>__private_key</strong> (Tuple[Tuple[int,...],...]):\nThe number corresponding to the sequence of operators.</li>\n<li><strong>function</strong> (QuasiPolynomial):\nThe corresponding coefficient function f(ell; m).</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">CoefficientFunction</span><span class=\"p\">(((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,)),</span> <span class=\"n\">QuasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">({</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]})))</span>\n<span class=\"go\">((-1, 1), (0,)): [(0, [&#39;1&#39;, &#39;2&#39;]), (3, [&#39;4&#39;, &#39;5&#39;])]</span>\n</code></pre>\n</div>\n\n<p>Prints the operator sequence m and the coefficient array of the corresponding coefficient function f(ell; m).</p>\n"}, {"fullname": "coefficientFunction.CoefficientFunction.__init__", "modulename": "coefficientFunction", "qualname": "CoefficientFunction.__init__", "kind": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>sequence</strong> (Tuple[Tuple[int,...],...]):\nThe operator sequence m identifying the function f(ell; m).</li>\n<li><strong>function</strong> (QuasiPolynomial):\nThe corresponding coefficient function f(ell; m).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sequence</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">function</span><span class=\"p\">:</span> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">QuasiPolynomial</span></span>)</span>"}, {"fullname": "coefficientFunction.CoefficientFunction.sequence", "modulename": "coefficientFunction", "qualname": "CoefficientFunction.sequence", "kind": "function", "doc": "<p>cf.sequence()</p>\n\n<p>Gets the operator sequence m identifying the function f(ell; m).</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[Tuple[int,...],...]</strong>: Operator sequence.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "coefficientFunction.CoefficientFunction.pretty_print", "modulename": "coefficientFunction", "qualname": "CoefficientFunction.pretty_print", "kind": "function", "doc": "<p>cf.pretty_print()</p>\n\n<p>Prints the operator sequence m and corresponding coefficient function f(ell; m).</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Operator sequence and human-readable quasi-polynomial.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "coefficientFunction.FunctionCollection", "modulename": "coefficientFunction", "qualname": "FunctionCollection", "kind": "class", "doc": "<p>FunctionCollection()</p>\n\n<p>A class used to store all calculated coefficient functions f(ell; m).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>translation</strong> (Dict):\nThe dictionary assigning an index to every operator.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>__private_collection</strong> (Dict):\nThe dictionary storing keys sequence_to_key(m) and values f(ell; m).</li>\n<li><strong>translation</strong> (Dict):\nThe dictionary assigning an index to every operator.</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">collection</span> <span class=\"o\">=</span> <span class=\"n\">FunctionCollection</span><span class=\"p\">({</span><span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">})</span>\n<span class=\"gp\">... </span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,),</span> <span class=\"p\">())</span> <span class=\"ow\">in</span> <span class=\"n\">collection</span>\n<span class=\"go\">False</span>\n</code></pre>\n</div>\n\n<p>Checks for the operator sequence m whether the function f(ell; m) is already calculated.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">collection</span><span class=\"p\">[((</span><span class=\"mi\">1</span><span class=\"p\">,),</span> <span class=\"p\">())]</span> <span class=\"o\">=</span> <span class=\"n\">QuasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">({</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]})</span>\n</code></pre>\n</div>\n\n<p>Saves the function f(ell; m) if it is not already saved.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">collection</span><span class=\"p\">[((</span><span class=\"mi\">1</span><span class=\"p\">,),</span> <span class=\"p\">())]</span>\n</code></pre>\n</div>\n\n<p>Returns for the operator sequence m the function f(ell; m) or None.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">collection</span><span class=\"p\">)</span>\n<span class=\"go\">[&quot;((1,), ()): [(0, [&#39;1&#39;, &#39;2&#39;]), (3, [&#39;4&#39;, &#39;5&#39;])]&quot;]</span>\n</code></pre>\n</div>\n\n<p>Prints the collection.</p>\n"}, {"fullname": "coefficientFunction.FunctionCollection.__init__", "modulename": "coefficientFunction", "qualname": "FunctionCollection.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]]</span></span>)</span>"}, {"fullname": "coefficientFunction.FunctionCollection.keys", "modulename": "coefficientFunction", "qualname": "FunctionCollection.keys", "kind": "function", "doc": "<p>FunctionCollection.keys()</p>\n\n<p>Returns all calculated operator sequences m.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>List[Tuple[Tuple[int,...],...]]</strong>: List of operator sequences in collection.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "coefficientFunction.FunctionCollection.pretty_print", "modulename": "coefficientFunction", "qualname": "FunctionCollection.pretty_print", "kind": "function", "doc": "<p>FunctionCollection.pretty_print()</p>\n\n<p>Transform the collection in a form suitable to be read by humans.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Collection as human-readable string.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "coefficientFunction.sequence_to_key", "modulename": "coefficientFunction", "qualname": "sequence_to_key", "kind": "function", "doc": "<p>vector_to_key(sequence)</p>\n\n<p>Converts the operator sequence m into the key.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[Tuple[int,...],...]</strong>: Key.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sequence</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "coefficientFunction.key_to_sequence", "modulename": "coefficientFunction", "qualname": "key_to_sequence", "kind": "function", "doc": "<p>key_to_sequence(key)</p>\n\n<p>Converts the key into the operator sequence m.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[Tuple[int,...],...]</strong>: Operator sequence.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "coefficientFunction.sequence_to_indices", "modulename": "coefficientFunction", "qualname": "sequence_to_indices", "kind": "function", "doc": "<p>sequence_to_indices(key)</p>\n\n<p>Converts the operator sequence into the indices of the operator sequence m.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[Tuple[Union[int,float,Fraction,complex],...],...]</strong>: Operator sequence indices.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sequence</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "coefficientFunction.calc", "modulename": "coefficientFunction", "qualname": "calc", "kind": "function", "doc": "<p>calc(sequence)</p>\n\n<p>Returns or calculates the function f(ell; m) corresponding to the operator sequence m.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>sequence</strong>: Operator sequence whose function is to be calculated.</li>\n<li><strong>collection</strong>: Function collection where the result is to be stored in.</li>\n<li><strong>translation</strong>: Dictionary translating operator indices to energy values.</li>\n<li><strong>max_energy</strong>: Width of the band diagonality band.</li>\n<li><strong>signum_func</strong>: Signum function to be used (normal, broad or complex).</li>\n<li><strong>energy_func</strong>: Energy function to be used (normal or broad).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>QuasiPolynomial</strong>: Calculated function f(ell; m).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sequence</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">collection</span><span class=\"p\">:</span> <span class=\"n\">coefficientFunction</span><span class=\"o\">.</span><span class=\"n\">FunctionCollection</span>,</span><span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">max_energy</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">signum_func</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]],</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">energy_func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]],</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">QuasiPolynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "coefficientFunction.trafo_calc", "modulename": "coefficientFunction", "qualname": "trafo_calc", "kind": "function", "doc": "<p>trafo_calc(sequence)</p>\n\n<p>Calculates the function G(ell; m) corresponding to the operator sequence m.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>sequence</strong>: Operator sequence whose function is to be calculated.</li>\n<li><strong>trafo_collection</strong>: Function collection where the result is to be stored in.</li>\n<li><strong>collection</strong>: Function collection where the resulting f(ell; m) are to be stored in.</li>\n<li><strong>translation</strong>: Dictionary translating operator indices to energy values.</li>\n<li><strong>max_energy</strong>: Width of the band diagonality band.</li>\n<li><strong>signum_func</strong>: Signum function to be used (normal, broad or complex).</li>\n<li><strong>energy_func</strong>: Energy function to be used (normal or broad).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>QuasiPolynomial</strong>: Calculated function G(ell; m).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sequence</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">trafo_collection</span><span class=\"p\">:</span> <span class=\"n\">coefficientFunction</span><span class=\"o\">.</span><span class=\"n\">FunctionCollection</span>,</span><span class=\"param\">\t<span class=\"n\">collection</span><span class=\"p\">:</span> <span class=\"n\">coefficientFunction</span><span class=\"o\">.</span><span class=\"n\">FunctionCollection</span>,</span><span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">max_energy</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">signum_func</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]],</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">energy_func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]],</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">QuasiPolynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "main", "modulename": "main", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "main.main", "modulename": "main", "qualname": "main", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raw_args</span><span class=\"p\">:</span> <span class=\"s1\">&#39;Sequence[str] | None&#39;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics", "modulename": "mathematics", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "mathematics.Expr", "modulename": "mathematics", "qualname": "Expr", "kind": "class", "doc": "<p>Base class for algebraic expressions.</p>\n\n<h1 id=\"explanation\">Explanation</h1>\n\n<p>Everything that requires arithmetic operations to be defined\nshould subclass this class, instead of Basic (which should be\nused only for argument storage and expression manipulation, i.e.\npattern matching, substitutions, etc).</p>\n\n<p>If you want to override the comparisons of expressions:\nShould use _eval_is_ge for inequality, or _eval_is_eq, with multiple dispatch.\n_eval_is_ge return true if x &gt;= y, false if x &lt; y, and None if the two types\nare not comparable or the comparison is indeterminate</p>\n\n<h1 id=\"see-also\">See Also</h1>\n\n<p>sympy.core.basic.Basic</p>\n", "bases": "sympy.core.basic.Basic, sympy.core.evalf.EvalfMixin"}, {"fullname": "mathematics.Expr.sort_key", "modulename": "mathematics", "qualname": "Expr.sort_key", "kind": "function", "doc": "<p>Return a sort key.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">S</span><span class=\"p\">,</span> <span class=\"n\">I</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">sorted</span><span class=\"p\">([</span><span class=\"n\">S</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">I</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"n\">I</span><span class=\"p\">],</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">sort_key</span><span class=\"p\">())</span>\n<span class=\"go\">[1/2, -I, I]</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">S</span><span class=\"p\">(</span><span class=\"s2\">&quot;[x, 1/x, 1/x**2, x**2, x**(1/2), x**(1/4), x**(3/2)]&quot;</span><span class=\"p\">)</span>\n<span class=\"go\">[x, 1/x, x**(-2), x**2, sqrt(x), x**(1/4), x**(3/2)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">sort_key</span><span class=\"p\">())</span>\n<span class=\"go\">[x**(-2), 1/x, x**(1/4), sqrt(x), x, x**(3/2), x**2]</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.is_number", "modulename": "mathematics", "qualname": "Expr.is_number", "kind": "variable", "doc": "<p>Returns True if <code>self</code> has no free symbols and no\nundefined functions (AppliedUndef, to be precise). It will be\nfaster than <code>if not self.free_symbols</code>, however, since\n<code>is_number</code> will fail as soon as it hits a free symbol\nor undefined function.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">Function</span><span class=\"p\">,</span> <span class=\"n\">Integral</span><span class=\"p\">,</span> <span class=\"n\">cos</span><span class=\"p\">,</span> <span class=\"n\">sin</span><span class=\"p\">,</span> <span class=\"n\">pi</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">Function</span><span class=\"p\">(</span><span class=\"s1\">&#39;f&#39;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">is_number</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_number</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_number</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">Integral</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">is_number</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">Integral</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)))</span><span class=\"o\">.</span><span class=\"n\">is_number</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n\n<p>Not all numbers are Numbers in the SymPy sense:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pi</span><span class=\"o\">.</span><span class=\"n\">is_number</span><span class=\"p\">,</span> <span class=\"n\">pi</span><span class=\"o\">.</span><span class=\"n\">is_Number</span>\n<span class=\"go\">(True, False)</span>\n</code></pre>\n</div>\n\n<p>If something is a number it should evaluate to a number with\nreal and imaginary parts that are Numbers; the result may not\nbe comparable, however, since the real and/or imaginary part\nof the result may not have precision.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_number</span> <span class=\"ow\">and</span> <span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_comparable</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">z</span><span class=\"o\">.</span><span class=\"n\">is_number</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">z</span><span class=\"o\">.</span><span class=\"n\">is_comparable</span>\n<span class=\"go\">False</span>\n</code></pre>\n</div>\n\n<h1 id=\"see-also\">See Also</h1>\n\n<p>sympy.core.basic.Basic.is_comparable</p>\n"}, {"fullname": "mathematics.Expr.is_constant", "modulename": "mathematics", "qualname": "Expr.is_constant", "kind": "function", "doc": "<p>Return True if self is constant, False if not, or None if\nthe constancy could not be determined conclusively.</p>\n\n<h1 id=\"explanation\">Explanation</h1>\n\n<p>If an expression has no free symbols then it is a constant. If\nthere are free symbols it is possible that the expression is a\nconstant, perhaps (but not necessarily) zero. To test such\nexpressions, a few strategies are tried:</p>\n\n<p>1) numerical evaluation at two random points. If two such evaluations\ngive two different values and the values have a precision greater than\n1 then self is not constant. If the evaluations agree or could not be\nobtained with any precision, no decision is made. The numerical testing\nis done only if <code>wrt</code> is different than the free symbols.</p>\n\n<p>2) differentiation with respect to variables in 'wrt' (or all free\nsymbols if omitted) to see if the expression is constant or not. This\nwill not always lead to an expression that is zero even though an\nexpression is constant (see added test in test_expr.py). If\nall derivatives are zero then self is constant with respect to the\ngiven symbols.</p>\n\n<p>3) finding out zeros of denominator expression with free_symbols.\nIt will not be constant if there are zeros. It gives more negative\nanswers for expression that are not constant.</p>\n\n<p>If neither evaluation nor differentiation can prove the expression is\nconstant, None is returned unless two numerical values happened to be\nthe same and the flag <code>failing_number</code> is True -- in that case the\nnumerical value will be returned.</p>\n\n<p>If flag simplify=False is passed, self will not be simplified;\nthe default is True since self should be simplified before testing.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">cos</span><span class=\"p\">,</span> <span class=\"n\">sin</span><span class=\"p\">,</span> <span class=\"n\">Sum</span><span class=\"p\">,</span> <span class=\"n\">S</span><span class=\"p\">,</span> <span class=\"n\">pi</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">is_constant</span><span class=\"p\">()</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">S</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_constant</span><span class=\"p\">()</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Sum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">is_constant</span><span class=\"p\">()</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Sum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">is_constant</span><span class=\"p\">()</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Sum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">is_constant</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Sum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">is_constant</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Sum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">is_constant</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eq</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">*</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">a</span><span class=\"o\">*</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">-</span> <span class=\"n\">a</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eq</span><span class=\"o\">.</span><span class=\"n\">is_constant</span><span class=\"p\">()</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eq</span><span class=\"o\">.</span><span class=\"n\">subs</span><span class=\"p\">({</span><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">pi</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">})</span> <span class=\"o\">==</span> <span class=\"n\">eq</span><span class=\"o\">.</span><span class=\"n\">subs</span><span class=\"p\">({</span><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">pi</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">})</span> <span class=\"o\">==</span> <span class=\"mi\">0</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"o\">**</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_constant</span><span class=\"p\">()</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">is_constant</span><span class=\"p\">()</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_constant</span><span class=\"p\">()</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">one</span> <span class=\"o\">=</span> <span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">one</span><span class=\"o\">.</span><span class=\"n\">is_constant</span><span class=\"p\">()</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">((</span><span class=\"n\">one</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">is_constant</span><span class=\"p\">()</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">)</span> <span class=\"c1\"># could be 0 or 1</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">wrt</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">flags</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.equals", "modulename": "mathematics", "qualname": "Expr.equals", "kind": "function", "doc": "<p>Return True if self == other, False if it doesn't, or None. If\nfailing_expression is True then the expression which did not simplify\nto a 0 will be returned instead of None.</p>\n\n<h1 id=\"explanation\">Explanation</h1>\n\n<p>If <code>self</code> is a Number (or complex number) that is not zero, then\nthe result is False.</p>\n\n<p>If <code>self</code> is a number and has not evaluated to zero, evalf will be\nused to test whether the expression evaluates to zero. If it does so\nand the result has significance (i.e. the precision is either -1, for\na Rational result, or is greater than 1) then the evalf value will be\nused to return True or False.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span>, </span><span class=\"param\"><span class=\"n\">failing_expression</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.conjugate", "modulename": "mathematics", "qualname": "Expr.conjugate", "kind": "function", "doc": "<p>Returns the complex conjugate of 'self'.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.dir", "modulename": "mathematics", "qualname": "Expr.dir", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">cdir</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.transpose", "modulename": "mathematics", "qualname": "Expr.transpose", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.adjoint", "modulename": "mathematics", "qualname": "Expr.adjoint", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_ordered_factors", "modulename": "mathematics", "qualname": "Expr.as_ordered_factors", "kind": "function", "doc": "<p>Return list of ordered factors (if Mul) else [self].</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_poly", "modulename": "mathematics", "qualname": "Expr.as_poly", "kind": "function", "doc": "<p>Converts <code>self</code> to a polynomial or returns <code>None</code>.</p>\n\n<h1 id=\"explanation\">Explanation</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">sin</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">((</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_poly</span><span class=\"p\">())</span>\n<span class=\"go\">Poly(x**2 + x*y, x, y, domain=&#39;ZZ&#39;)</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">((</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_poly</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">))</span>\n<span class=\"go\">Poly(x**2 + x*y, x, y, domain=&#39;ZZ&#39;)</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">((</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">as_poly</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">))</span>\n<span class=\"go\">None</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">gens</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">args</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_ordered_terms", "modulename": "mathematics", "qualname": "Expr.as_ordered_terms", "kind": "function", "doc": "<p>Transform an expression to an ordered list of terms.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">sin</span><span class=\"p\">,</span> <span class=\"n\">cos</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_ordered_terms</span><span class=\"p\">()</span>\n<span class=\"go\">[sin(x)**2*cos(x), sin(x)**2, 1]</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_terms", "modulename": "mathematics", "qualname": "Expr.as_terms", "kind": "function", "doc": "<p>Transform an expression to a list of terms.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.removeO", "modulename": "mathematics", "qualname": "Expr.removeO", "kind": "function", "doc": "<p>Removes the additive O(..) symbol if there is one</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.getO", "modulename": "mathematics", "qualname": "Expr.getO", "kind": "function", "doc": "<p>Returns the additive O(..) symbol if there is one, else None.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.getn", "modulename": "mathematics", "qualname": "Expr.getn", "kind": "function", "doc": "<p>Returns the order of the expression.</p>\n\n<h1 id=\"explanation\">Explanation</h1>\n\n<p>The order is determined either from the O(...) term. If there\nis no O(...) term, it returns None.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">O</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">O</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">getn</span><span class=\"p\">()</span>\n<span class=\"go\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">getn</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.count_ops", "modulename": "mathematics", "qualname": "Expr.count_ops", "kind": "function", "doc": "<p>wrapper for count_ops that returns the operation count.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">visual</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.args_cnc", "modulename": "mathematics", "qualname": "Expr.args_cnc", "kind": "function", "doc": "<p>Return [commutative factors, non-commutative factors] of self.</p>\n\n<h1 id=\"explanation\">Explanation</h1>\n\n<p>self is treated as a Mul and the ordering of the factors is maintained.\nIf <code>cset</code> is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting <code>warn</code> to False.</p>\n\n<p>Note: -1 is always separated from a Number unless split_1 is False.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">symbols</span><span class=\"p\">,</span> <span class=\"n\">oo</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">B</span> <span class=\"o\">=</span> <span class=\"n\">symbols</span><span class=\"p\">(</span><span class=\"s1\">&#39;A B&#39;</span><span class=\"p\">,</span> <span class=\"n\">commutative</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">symbols</span><span class=\"p\">(</span><span class=\"s1\">&#39;x y&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args_cnc</span><span class=\"p\">()</span>\n<span class=\"go\">[[-1, 2, x, y], []]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mf\">2.5</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args_cnc</span><span class=\"p\">()</span>\n<span class=\"go\">[[-1, 2.5, x], []]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">A</span><span class=\"o\">*</span><span class=\"n\">B</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args_cnc</span><span class=\"p\">()</span>\n<span class=\"go\">[[-1, 2, x, y], [A, B]]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">A</span><span class=\"o\">*</span><span class=\"n\">B</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args_cnc</span><span class=\"p\">(</span><span class=\"n\">split_1</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"go\">[[-2, x, y], [A, B]]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args_cnc</span><span class=\"p\">(</span><span class=\"n\">cset</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">[{-1, 2, x, y}, []]</span>\n</code></pre>\n</div>\n\n<p>The arg is always treated as a Mul:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">A</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args_cnc</span><span class=\"p\">()</span>\n<span class=\"go\">[[], [x - 2 + A]]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">oo</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">args_cnc</span><span class=\"p\">()</span> <span class=\"c1\"># -oo is a singleton</span>\n<span class=\"go\">[[-1, oo], []]</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cset</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">warn</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">split_1</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.coeff", "modulename": "mathematics", "qualname": "Expr.coeff", "kind": "function", "doc": "<p>Returns the coefficient from the term(s) containing <code>x**n</code>. If <code>n</code>\nis zero then all terms independent of <code>x</code> will be returned.</p>\n\n<h1 id=\"explanation\">Explanation</h1>\n\n<p>When <code>x</code> is noncommutative, the coefficient to the left (default) or\nright of <code>x</code> can be returned. The keyword 'right' is ignored when\n<code>x</code> is commutative.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">symbols</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">z</span>\n</code></pre>\n</div>\n\n<p>You can select terms that have an explicit negative in front of them:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">x</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">-</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">2*y</span>\n</code></pre>\n</div>\n\n<p>You can select terms with no Rational coefficient:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">x</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">0</span>\n</code></pre>\n</div>\n\n<p>You can select terms independent of x by making n=0; in this case\nexpr.as_independent(x)[0] is returned (and 0 will be returned instead\nof None):</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"go\">3</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eq</span> <span class=\"o\">=</span> <span class=\"p\">((</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">expand</span><span class=\"p\">()</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eq</span>\n<span class=\"go\">x**3 + 3*x**2 + 3*x + 2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">[</span><span class=\"n\">eq</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">reversed</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">))]</span>\n<span class=\"go\">[1, 3, 3, 2]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eq</span> <span class=\"o\">-=</span> <span class=\"mi\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">[</span><span class=\"n\">eq</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">reversed</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">))]</span>\n<span class=\"go\">[1, 3, 3, 0]</span>\n</code></pre>\n</div>\n\n<p>You can select terms that have a numerical term in front of them:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">x</span> <span class=\"o\">-</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"go\">-y</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">sqrt</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">))</span>\n<span class=\"go\">x</span>\n</code></pre>\n</div>\n\n<p>The matching is exact:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"go\">4</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"go\">0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">z</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">((</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"go\">z</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">z</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"go\">0</span>\n</code></pre>\n</div>\n\n<p>In addition, no factoring is done, so 1 + z*(1 + y) is not obtained\nfrom the following:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">z</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">1</span>\n</code></pre>\n</div>\n\n<p>If such factoring is desired, factor_terms can be used first:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">factor_terms</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">factor_terms</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">z</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">z*(y + 1) + 1</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">m</span><span class=\"p\">,</span> <span class=\"n\">o</span> <span class=\"o\">=</span> <span class=\"n\">symbols</span><span class=\"p\">(</span><span class=\"s1\">&#39;n m o&#39;</span><span class=\"p\">,</span> <span class=\"n\">commutative</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n<span class=\"go\">1</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n<span class=\"go\">3</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">*</span><span class=\"n\">m</span> <span class=\"o\">+</span> <span class=\"n\">m</span><span class=\"o\">*</span><span class=\"n\">n</span><span class=\"o\">*</span><span class=\"n\">m</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"c1\"># = (1 + m)*n*m</span>\n<span class=\"go\">1 + m</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">*</span><span class=\"n\">m</span> <span class=\"o\">+</span> <span class=\"n\">m</span><span class=\"o\">*</span><span class=\"n\">n</span><span class=\"o\">*</span><span class=\"n\">m</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"c1\"># = (1 + m)*n*m</span>\n<span class=\"go\">m</span>\n</code></pre>\n</div>\n\n<p>If there is more than one possible coefficient 0 is returned:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">*</span><span class=\"n\">m</span> <span class=\"o\">+</span> <span class=\"n\">m</span><span class=\"o\">*</span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n<span class=\"go\">0</span>\n</code></pre>\n</div>\n\n<p>If there is only one possible coefficient, it is returned:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">*</span><span class=\"n\">m</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">m</span><span class=\"o\">*</span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"o\">*</span><span class=\"n\">n</span><span class=\"p\">)</span>\n<span class=\"go\">x</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">*</span><span class=\"n\">m</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">m</span><span class=\"o\">*</span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"o\">*</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">1</span>\n</code></pre>\n</div>\n\n<h1 id=\"see-also\">See Also</h1>\n\n<p>as_coefficient: separate the expression into a coefficient and factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">right</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">_first</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_expr", "modulename": "mathematics", "qualname": "Expr.as_expr", "kind": "function", "doc": "<p>Convert a polynomial to a SymPy expression.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">sin</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_poly</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">as_expr</span><span class=\"p\">()</span>\n<span class=\"go\">x**2 + x*y</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_expr</span><span class=\"p\">()</span>\n<span class=\"go\">sin(x)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">gens</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_coefficient", "modulename": "mathematics", "qualname": "Expr.as_coefficient", "kind": "function", "doc": "<p>Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">E</span><span class=\"p\">,</span> <span class=\"n\">pi</span><span class=\"p\">,</span> <span class=\"n\">sin</span><span class=\"p\">,</span> <span class=\"n\">I</span><span class=\"p\">,</span> <span class=\"n\">Poly</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">E</span><span class=\"o\">.</span><span class=\"n\">as_coefficient</span><span class=\"p\">(</span><span class=\"n\">E</span><span class=\"p\">)</span>\n<span class=\"go\">1</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">E</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_coefficient</span><span class=\"p\">(</span><span class=\"n\">E</span><span class=\"p\">)</span>\n<span class=\"go\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">E</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">E</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_coefficient</span><span class=\"p\">(</span><span class=\"n\">E</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Two terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">E</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">E</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_coefficient</span><span class=\"p\">(</span><span class=\"n\">E</span><span class=\"p\">)</span>\n<span class=\"go\">x + 2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">_</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"c1\"># just want the exact match</span>\n<span class=\"go\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">Poly</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">E</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">E</span><span class=\"p\">);</span> <span class=\"n\">p</span>\n<span class=\"go\">Poly(x*E + 2*E, x, E, domain=&#39;ZZ&#39;)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">coeff_monomial</span><span class=\"p\">(</span><span class=\"n\">E</span><span class=\"p\">)</span>\n<span class=\"go\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">nth</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">2</span>\n</code></pre>\n</div>\n\n<p>Since the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient <code>2*x</code> is\ndesired then the <code>coeff</code> method should be used.)</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">E</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_coefficient</span><span class=\"p\">(</span><span class=\"n\">E</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">E</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">coeff</span><span class=\"p\">(</span><span class=\"n\">E</span><span class=\"p\">)</span>\n<span class=\"go\">2*x</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">E</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_coefficient</span><span class=\"p\">(</span><span class=\"n\">E</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">pi</span><span class=\"o\">*</span><span class=\"n\">I</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_coefficient</span><span class=\"p\">(</span><span class=\"n\">pi</span><span class=\"o\">*</span><span class=\"n\">I</span><span class=\"p\">)</span>\n<span class=\"go\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">I</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_coefficient</span><span class=\"p\">(</span><span class=\"n\">pi</span><span class=\"o\">*</span><span class=\"n\">I</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<h1 id=\"see-also\">See Also</h1>\n\n<p>coeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">expr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_independent", "modulename": "mathematics", "qualname": "Expr.as_independent", "kind": "function", "doc": "<p>A mostly naive separation of a Mul or Add into arguments that are not\nare dependent on deps. To obtain as complete a separation of variables\nas possible, use a separation method first, e.g.:</p>\n\n<ul>\n<li>separatevars() to change Mul, Add and Pow (including exp) into Mul</li>\n<li>.expand(mul=True) to change Add or Mul into Add</li>\n<li>.expand(log=True) to change log expr into an Add</li>\n</ul>\n\n<p>The only non-naive thing that is done here is to respect noncommutative\nordering of variables and to always return (0, 0) for <code>self</code> of zero\nregardless of hints.</p>\n\n<p>For nonzero <code>self</code>, the returned tuple (i, d) has the\nfollowing interpretation:</p>\n\n<ul>\n<li>i will has no variable that appears in deps</li>\n<li>d will either have terms that contain variables that are in deps, or\nbe equal to 0 (when self is an Add) or 1 (when self is a Mul)</li>\n<li>if self is an Add then self = i + d</li>\n<li>if self is a Mul then self = i*d</li>\n<li>otherwise (self, S.One) or (S.One, self) is returned.</li>\n</ul>\n\n<p>To force the expression to be treated as an Add, use the hint as_Add=True</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<p>-- self is an Add</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">sin</span><span class=\"p\">,</span> <span class=\"n\">cos</span><span class=\"p\">,</span> <span class=\"n\">exp</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">z</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">(0, x*y + x)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"go\">(x, x*y)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">y</span> <span class=\"o\">+</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">z</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">(y + z, 2*x*sin(x) + x)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">y</span> <span class=\"o\">+</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">z</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"go\">(z, 2*x*sin(x) + x + y)</span>\n</code></pre>\n</div>\n\n<p>-- self is a Mul</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">(cos(y), x*sin(x))</span>\n</code></pre>\n</div>\n\n<p>non-commutative terms cannot always be separated out when self is a Mul</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">symbols</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">n1</span><span class=\"p\">,</span> <span class=\"n\">n2</span><span class=\"p\">,</span> <span class=\"n\">n3</span> <span class=\"o\">=</span> <span class=\"n\">symbols</span><span class=\"p\">(</span><span class=\"s1\">&#39;n1 n2 n3&#39;</span><span class=\"p\">,</span> <span class=\"n\">commutative</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">n1</span> <span class=\"o\">+</span> <span class=\"n\">n1</span><span class=\"o\">*</span><span class=\"n\">n2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">n2</span><span class=\"p\">)</span>\n<span class=\"go\">(n1, n1*n2)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">n2</span><span class=\"o\">*</span><span class=\"n\">n1</span> <span class=\"o\">+</span> <span class=\"n\">n1</span><span class=\"o\">*</span><span class=\"n\">n2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">n2</span><span class=\"p\">)</span>\n<span class=\"go\">(0, n1*n2 + n2*n1)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">n1</span><span class=\"o\">*</span><span class=\"n\">n2</span><span class=\"o\">*</span><span class=\"n\">n3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">n1</span><span class=\"p\">)</span>\n<span class=\"go\">(1, n1*n2*n3)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">n1</span><span class=\"o\">*</span><span class=\"n\">n2</span><span class=\"o\">*</span><span class=\"n\">n3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">n2</span><span class=\"p\">)</span>\n<span class=\"go\">(n1, n2*n3)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">((</span><span class=\"n\">x</span><span class=\"o\">-</span><span class=\"n\">n1</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">-</span><span class=\"n\">y</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">(1, (x - y)*(x - n1))</span>\n</code></pre>\n</div>\n\n<p>-- self is anything else:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">(1, sin(x))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"go\">(sin(x), 1)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">+</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">(1, exp(x + y))</span>\n</code></pre>\n</div>\n\n<p>-- force self to be treated as an Add:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">as_Add</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">(0, 3*x)</span>\n</code></pre>\n</div>\n\n<p>-- force self to be treated as a Mul:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"o\">+</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">as_Add</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"go\">(1, x + 3)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"o\">+</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">as_Add</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"go\">(1, x - 3)</span>\n</code></pre>\n</div>\n\n<p>Note how the below differs from the above in making the\nconstant on the dep term positive.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"o\">+</span><span class=\"n\">x</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">(y, x - 3)</span>\n</code></pre>\n</div>\n\n<p>-- use .as_independent() for true independence testing instead\n   of .has(). The former considers only symbols in the free\n   symbols while the latter considers all symbols</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">Integral</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">I</span> <span class=\"o\">=</span> <span class=\"n\">Integral</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">I</span><span class=\"o\">.</span><span class=\"n\">has</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"n\">I</span><span class=\"o\">.</span><span class=\"n\">free_symbols</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">I</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"n\">I</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">I</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"n\">I</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n\n<p>Note: when trying to get independent terms, a separation method\nmight need to be used first. In this case, it is important to keep\ntrack of what you send to this routine so you know how to interpret\nthe returned values</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">separatevars</span><span class=\"p\">,</span> <span class=\"n\">log</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">separatevars</span><span class=\"p\">(</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">+</span><span class=\"n\">y</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">(exp(y), exp(x))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"go\">(x, x*y)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">separatevars</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"go\">(x, y + 1)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"go\">(x, y + 1)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">expand</span><span class=\"p\">(</span><span class=\"n\">mul</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"go\">(x, x*y)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">=</span><span class=\"n\">symbols</span><span class=\"p\">(</span><span class=\"s1\">&#39;a b&#39;</span><span class=\"p\">,</span> <span class=\"n\">positive</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">expand</span><span class=\"p\">(</span><span class=\"n\">log</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">as_independent</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"go\">(log(a), log(b))</span>\n</code></pre>\n</div>\n\n<h1 id=\"see-also\">See Also</h1>\n\n<p>.separatevars(), .expand(log=True), sympy.core.add.Add.as_two_terms(),\nsympy.core.mul.Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">deps</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">hint</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_real_imag", "modulename": "mathematics", "qualname": "Expr.as_real_imag", "kind": "function", "doc": "<p>Performs complex expansion on 'self' and returns a tuple\ncontaining collected both real and imaginary parts. This\nmethod cannot be confused with re() and im() functions,\nwhich does not perform complex expansion at evaluation.</p>\n\n<p>However it is possible to expand both re() and im()\nfunctions and get exactly the same results as with\na single call to this function.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">symbols</span><span class=\"p\">,</span> <span class=\"n\">I</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">symbols</span><span class=\"p\">(</span><span class=\"s1\">&#39;x,y&#39;</span><span class=\"p\">,</span> <span class=\"n\">real</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"o\">*</span><span class=\"n\">I</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_real_imag</span><span class=\"p\">()</span>\n<span class=\"go\">(x, y)</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">z</span><span class=\"p\">,</span> <span class=\"n\">w</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">z</span> <span class=\"o\">+</span> <span class=\"n\">w</span><span class=\"o\">*</span><span class=\"n\">I</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_real_imag</span><span class=\"p\">()</span>\n<span class=\"go\">(re(z) - im(w), re(w) + im(z))</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">deep</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">hints</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_powers_dict", "modulename": "mathematics", "qualname": "Expr.as_powers_dict", "kind": "function", "doc": "<p>Return self as a dictionary of factors with each factor being\ntreated as a power. The keys are the bases of the factors and the\nvalues, the corresponding exponents. The resulting dictionary should\nbe used with caution if the expression is a Mul and contains non-\ncommutative factors since the order that they appeared will be lost in\nthe dictionary.</p>\n\n<h1 id=\"see-also\">See Also</h1>\n\n<p>as_ordered_factors: An alternative for noncommutative applications,\n                    returning an ordered list of factors.\nargs_cnc: Similar to as_ordered_factors, but guarantees separation\n          of commutative and noncommutative factors.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_coefficients_dict", "modulename": "mathematics", "qualname": "Expr.as_coefficients_dict", "kind": "function", "doc": "<p>Return a dictionary mapping terms to their Rational coefficient.\nSince the dictionary is a defaultdict, inquiries about terms which\nwere not present will return a coefficient of 0. If an expression is\nnot an Add it is considered to have a single term.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">x</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">a</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">4</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_coefficients_dict</span><span class=\"p\">()</span>\n<span class=\"go\">{1: 4, x: 3, a*x: 1}</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">_</span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span>\n<span class=\"go\">0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_coefficients_dict</span><span class=\"p\">()</span>\n<span class=\"go\">{a*x: 3}</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_base_exp", "modulename": "mathematics", "qualname": "Expr.as_base_exp", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_coeff_mul", "modulename": "mathematics", "qualname": "Expr.as_coeff_mul", "kind": "function", "doc": "<p>Return the tuple (c, args) where self is written as a Mul, <code>m</code>.</p>\n\n<p>c should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.</p>\n\n<p>args should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).</p>\n\n<p>This should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.</p>\n\n<ul>\n<li>if you know self is a Mul and want only the head, use self.args[0];</li>\n<li>if you do not want to process the arguments of the tail but need the\ntail then use self.as_two_terms() which gives the head and tail;</li>\n<li>if you want to split self into an independent and dependent parts\nuse <code>self.as_independent(*deps)</code></li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">S</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">as_coeff_mul</span><span class=\"p\">()</span>\n<span class=\"go\">(3, ())</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_coeff_mul</span><span class=\"p\">()</span>\n<span class=\"go\">(3, (x, y))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_coeff_mul</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">(3*y, (x,))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_coeff_mul</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">(3*y, ())</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">deps</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_coeff_add", "modulename": "mathematics", "qualname": "Expr.as_coeff_add", "kind": "function", "doc": "<p>Return the tuple (c, args) where self is written as an Add, <code>a</code>.</p>\n\n<p>c should be a Rational added to any terms of the Add that are\nindependent of deps.</p>\n\n<p>args should be a tuple of all other terms of <code>a</code>; args is empty\nif self is a Number or if self is independent of deps (when given).</p>\n\n<p>This should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.</p>\n\n<ul>\n<li>if you know self is an Add and want only the head, use self.args[0];</li>\n<li>if you do not want to process the arguments of the tail but need the\ntail then use self.as_two_terms() which gives the head and tail.</li>\n<li>if you want to split self into an independent and dependent parts\nuse <code>self.as_independent(*deps)</code></li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">S</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">as_coeff_add</span><span class=\"p\">()</span>\n<span class=\"go\">(3, ())</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_coeff_add</span><span class=\"p\">()</span>\n<span class=\"go\">(3, (x,))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_coeff_add</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">(y + 3, (x,))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_coeff_add</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">(y + 3, ())</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">deps</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.primitive", "modulename": "mathematics", "qualname": "Expr.primitive", "kind": "function", "doc": "<p>Return the positive Rational that can be extracted non-recursively\nfrom every term of self (i.e., self is treated like an Add). This is\nlike the as_coeff_Mul() method but primitive always extracts a positive\nRational (never a negative or a Float).</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">primitive</span><span class=\"p\">()</span>\n<span class=\"go\">(3, (x + 1)**2)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">6</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">);</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">primitive</span><span class=\"p\">()</span>\n<span class=\"go\">(2, 3*x + 1)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">/</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"p\">);</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">primitive</span><span class=\"p\">()</span>\n<span class=\"go\">(1/2, x + 6)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">primitive</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_content_primitive", "modulename": "mathematics", "qualname": "Expr.as_content_primitive", "kind": "function", "doc": "<p>This method should recursively remove a Rational from all arguments\nand return that (content) and the new self (primitive). The content\nshould always be positive and <code>Mul(*foo.as_content_primitive()) == foo</code>.\nThe primitive need not be in canonical form and should try to preserve\nthe underlying structure if possible (i.e. expand_mul should not be\napplied to self).</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">sqrt</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">z</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eq</span> <span class=\"o\">=</span> <span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>The as_content_primitive function is recursive and retains structure:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eq</span><span class=\"o\">.</span><span class=\"n\">as_content_primitive</span><span class=\"p\">()</span>\n<span class=\"go\">(2, x + 3*y*(y + 1) + 1)</span>\n</code></pre>\n</div>\n\n<p>Integer powers will have Rationals extracted from the base:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">((</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">6</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_content_primitive</span><span class=\"p\">()</span>\n<span class=\"go\">(4, (3*x + 1)**2)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">((</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">6</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">as_content_primitive</span><span class=\"p\">()</span>\n<span class=\"go\">(1, (2*(3*x + 1))**(2*y))</span>\n</code></pre>\n</div>\n\n<p>Terms may end up joining once their as_content_primitives are added:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">((</span><span class=\"mi\">5</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">))</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)))</span><span class=\"o\">.</span><span class=\"n\">as_content_primitive</span><span class=\"p\">()</span>\n<span class=\"go\">(11, x*(y + 1))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">((</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">))</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)))</span><span class=\"o\">.</span><span class=\"n\">as_content_primitive</span><span class=\"p\">()</span>\n<span class=\"go\">(9, x*(y + 1))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">((</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">z</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">))</span> <span class=\"o\">+</span> <span class=\"mf\">2.0</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)))</span><span class=\"o\">.</span><span class=\"n\">as_content_primitive</span><span class=\"p\">()</span>\n<span class=\"go\">(1, 6.0*x*(y + 1) + 3*z*(y + 1))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">((</span><span class=\"mi\">5</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">))</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">))</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_content_primitive</span><span class=\"p\">()</span>\n<span class=\"go\">(121, x**2*(y + 1)**2)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">((</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mf\">0.4</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">))</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_content_primitive</span><span class=\"p\">()</span>\n<span class=\"go\">(1, 4.84*x**2*(y + 1)**2)</span>\n</code></pre>\n</div>\n\n<p>Radical content can also be factored out of the primitive:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">as_content_primitive</span><span class=\"p\">(</span><span class=\"n\">radical</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">(2, sqrt(2)*(1 + 2*sqrt(5)))</span>\n</code></pre>\n</div>\n\n<p>If clear=False (default is True) then content will not be removed\nfrom an Add if it can be distributed to leave one or more\nterms with integer coefficients.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">/</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_content_primitive</span><span class=\"p\">()</span>\n<span class=\"go\">(1/2, x + 2*y)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">/</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_content_primitive</span><span class=\"p\">(</span><span class=\"n\">clear</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"go\">(1, x/2 + y)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">radical</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">clear</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_numer_denom", "modulename": "mathematics", "qualname": "Expr.as_numer_denom", "kind": "function", "doc": "<p>expression -> a/b -> a, b</p>\n\n<p>This is just a stub that should be defined by\nan object's class methods to get anything else.</p>\n\n<h1 id=\"see-also\">See Also</h1>\n\n<p>normal: return <code>a/b</code> instead of <code>(a, b)</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.normal", "modulename": "mathematics", "qualname": "Expr.normal", "kind": "function", "doc": "<p>expression -> a/b</p>\n\n<h1 id=\"see-also\">See Also</h1>\n\n<p>as_numer_denom: return <code>(a, b)</code> instead of <code>a/b</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.extract_multiplicatively", "modulename": "mathematics", "qualname": "Expr.extract_multiplicatively", "kind": "function", "doc": "<p>Return None if it's not possible to make self in the form\nc * something in a nice way, i.e. preserving the properties\nof arguments of self.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">symbols</span><span class=\"p\">,</span> <span class=\"n\">Rational</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">symbols</span><span class=\"p\">(</span><span class=\"s1\">&#39;x,y&#39;</span><span class=\"p\">,</span> <span class=\"n\">real</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">((</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">extract_multiplicatively</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"go\">x*y**2</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">((</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">extract_multiplicatively</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">4</span> <span class=\"o\">*</span> <span class=\"n\">y</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">extract_multiplicatively</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"go\">x</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">extract_multiplicatively</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">Rational</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">extract_multiplicatively</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"go\">x/6</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.extract_additively", "modulename": "mathematics", "qualname": "Expr.extract_additively", "kind": "function", "doc": "<p>Return self - c if it's possible to subtract c from self and\nmake all matching coefficients move towards zero, else return None.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">3</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">extract_additively</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">x + 2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">extract_additively</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">extract_additively</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">extract_additively</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">((</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">y</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">extract_additively</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">(x + 1)*(x + 2*y) + 3</span>\n</code></pre>\n</div>\n\n<h1 id=\"see-also\">See Also</h1>\n\n<p>extract_multiplicatively\ncoeff\nas_coefficient</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">c</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.expr_free_symbols", "modulename": "mathematics", "qualname": "Expr.expr_free_symbols", "kind": "variable", "doc": "<p>Like <code>free_symbols</code>, but returns the free symbols only if\nthey are contained in an expression node.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">expr_free_symbols</span> <span class=\"c1\"># doctest: +SKIP</span>\n<span class=\"go\">{x, y}</span>\n</code></pre>\n</div>\n\n<p>If the expression is contained in a non-expression object, do not return\nthe free symbols. Compare:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">Tuple</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">Tuple</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">expr_free_symbols</span> <span class=\"c1\"># doctest: +SKIP</span>\n<span class=\"go\">set()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">free_symbols</span>\n<span class=\"go\">{x, y}</span>\n</code></pre>\n</div>\n"}, {"fullname": "mathematics.Expr.could_extract_minus_sign", "modulename": "mathematics", "qualname": "Expr.could_extract_minus_sign", "kind": "function", "doc": "<p>Return True if self has -1 as a leading factor or has\nmore literal negative signs than positive signs in a sum,\notherwise False.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">-</span> <span class=\"n\">y</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">{</span><span class=\"n\">i</span><span class=\"o\">.</span><span class=\"n\">could_extract_minus_sign</span><span class=\"p\">()</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"n\">e</span><span class=\"p\">)}</span>\n<span class=\"go\">{False, True}</span>\n</code></pre>\n</div>\n\n<p>Though the <code>y - x</code> is considered like <code>-(x - y)</code>, since it\nis in a product without a leading factor of -1, the result is\nfalse below:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">could_extract_minus_sign</span><span class=\"p\">()</span>\n<span class=\"go\">False</span>\n</code></pre>\n</div>\n\n<p>To put something in canonical form wrt to sign, use <code>signsimp</code>:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">signsimp</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">signsimp</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">))</span>\n<span class=\"go\">-x*(x - y)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">_</span><span class=\"o\">.</span><span class=\"n\">could_extract_minus_sign</span><span class=\"p\">()</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.extract_branch_factor", "modulename": "mathematics", "qualname": "Expr.extract_branch_factor", "kind": "function", "doc": "<p>Try to write self as <code>exp_polar(2*pi*I*n)*z</code> in a nice way.\nReturn (z, n).</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">exp_polar</span><span class=\"p\">,</span> <span class=\"n\">I</span><span class=\"p\">,</span> <span class=\"n\">pi</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">exp_polar</span><span class=\"p\">(</span><span class=\"n\">I</span><span class=\"o\">*</span><span class=\"n\">pi</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">extract_branch_factor</span><span class=\"p\">()</span>\n<span class=\"go\">(exp_polar(I*pi), 0)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">exp_polar</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">I</span><span class=\"o\">*</span><span class=\"n\">pi</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">extract_branch_factor</span><span class=\"p\">()</span>\n<span class=\"go\">(1, 1)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">exp_polar</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">pi</span><span class=\"o\">*</span><span class=\"n\">I</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">extract_branch_factor</span><span class=\"p\">()</span>\n<span class=\"go\">(exp_polar(I*pi), -1)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">exp_polar</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">pi</span><span class=\"o\">*</span><span class=\"n\">I</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">extract_branch_factor</span><span class=\"p\">()</span>\n<span class=\"go\">(exp_polar(x + I*pi), 1)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"o\">*</span><span class=\"n\">exp_polar</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">5</span><span class=\"o\">*</span><span class=\"n\">pi</span><span class=\"o\">*</span><span class=\"n\">I</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">exp_polar</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">pi</span><span class=\"o\">*</span><span class=\"n\">I</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">pi</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">extract_branch_factor</span><span class=\"p\">()</span>\n<span class=\"go\">(y*exp_polar(2*pi*x), -1)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">exp_polar</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">I</span><span class=\"o\">*</span><span class=\"n\">pi</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">extract_branch_factor</span><span class=\"p\">()</span>\n<span class=\"go\">(exp_polar(-I*pi/2), 0)</span>\n</code></pre>\n</div>\n\n<p>If allow_half is True, also extract exp_polar(I*pi):</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">exp_polar</span><span class=\"p\">(</span><span class=\"n\">I</span><span class=\"o\">*</span><span class=\"n\">pi</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">extract_branch_factor</span><span class=\"p\">(</span><span class=\"n\">allow_half</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">(1, 1/2)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">exp_polar</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">I</span><span class=\"o\">*</span><span class=\"n\">pi</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">extract_branch_factor</span><span class=\"p\">(</span><span class=\"n\">allow_half</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">(1, 1)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">exp_polar</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">I</span><span class=\"o\">*</span><span class=\"n\">pi</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">extract_branch_factor</span><span class=\"p\">(</span><span class=\"n\">allow_half</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">(1, 3/2)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">exp_polar</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">I</span><span class=\"o\">*</span><span class=\"n\">pi</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">extract_branch_factor</span><span class=\"p\">(</span><span class=\"n\">allow_half</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">(1, -1/2)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">allow_half</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.is_polynomial", "modulename": "mathematics", "qualname": "Expr.is_polynomial", "kind": "function", "doc": "<p>Return True if self is a polynomial in syms and False otherwise.</p>\n\n<p>This checks if self is an exact polynomial in syms.  This function\nreturns False for expressions that are \"polynomials\" with symbolic\nexponents.  Thus, you should be able to apply polynomial algorithms to\nexpressions for which this returns True, and Poly(expr, *syms) should\nwork if and only if expr.is_polynomial(*syms) returns True. The\npolynomial does not have to be in expanded form.  If no symbols are\ngiven, all free symbols in the expression will be used.</p>\n\n<p>This is not part of the assumptions system.  You cannot do\nSymbol('z', polynomial=True).</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">Symbol</span><span class=\"p\">,</span> <span class=\"n\">Function</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">((</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">4</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_polynomial</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">((</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">4</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_polynomial</span><span class=\"p\">()</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">**</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_polynomial</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">**</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_polynomial</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">**</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">Function</span><span class=\"p\">(</span><span class=\"s1\">&#39;f&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_polynomial</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_polynomial</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">))</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_polynomial</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">))</span>\n<span class=\"go\">False</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s1\">&#39;n&#39;</span><span class=\"p\">,</span> <span class=\"n\">nonnegative</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">integer</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_polynomial</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">False</span>\n</code></pre>\n</div>\n\n<p>This function does not attempt any nontrivial simplifications that may\nresult in an expression that does not appear to be a polynomial to\nbecome one.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">sqrt</span><span class=\"p\">,</span> <span class=\"n\">factor</span><span class=\"p\">,</span> <span class=\"n\">cancel</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s1\">&#39;y&#39;</span><span class=\"p\">,</span> <span class=\"n\">positive</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">y</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">is_polynomial</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">factor</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"go\">y + 1</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">factor</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_polynomial</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">y</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">y</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">is_polynomial</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">cancel</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"go\">y + 1</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">cancel</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_polynomial</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n\n<p>See also .is_rational_function()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">syms</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.is_rational_function", "modulename": "mathematics", "qualname": "Expr.is_rational_function", "kind": "function", "doc": "<p>Test whether function is a ratio of two polynomials in the given\nsymbols, syms. When syms is not given, all free symbols will be used.\nThe rational function does not have to be in expanded or in any kind of\ncanonical form.</p>\n\n<p>This function returns False for expressions that are \"rational\nfunctions\" with symbolic exponents.  Thus, you should be able to call\n.as_numer_denom() and apply polynomial algorithms to the result for\nexpressions for which this returns True.</p>\n\n<p>This is not part of the assumptions system.  You cannot do\nSymbol('z', rational_function=True).</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">Symbol</span><span class=\"p\">,</span> <span class=\"n\">sin</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">/</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_rational_function</span><span class=\"p\">()</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_rational_function</span><span class=\"p\">()</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">/</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">is_rational_function</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"go\">False</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s1\">&#39;n&#39;</span><span class=\"p\">,</span> <span class=\"n\">integer</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_rational_function</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">False</span>\n</code></pre>\n</div>\n\n<p>This function does not attempt any nontrivial simplifications that may\nresult in an expression that does not appear to be a rational function\nto become one.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">sqrt</span><span class=\"p\">,</span> <span class=\"n\">factor</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s1\">&#39;y&#39;</span><span class=\"p\">,</span> <span class=\"n\">positive</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">y</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"n\">y</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">is_rational_function</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">factor</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"go\">(y + 1)/y</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">factor</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_rational_function</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n\n<p>See also is_algebraic_expr().</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">syms</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.is_meromorphic", "modulename": "mathematics", "qualname": "Expr.is_meromorphic", "kind": "function", "doc": "<p>This tests whether an expression is meromorphic as\na function of the given symbol <code>x</code> at the point <code>a</code>.</p>\n\n<p>This method is intended as a quick test that will return\nNone if no decision can be made without simplification or\nmore detailed analysis.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">zoo</span><span class=\"p\">,</span> <span class=\"n\">log</span><span class=\"p\">,</span> <span class=\"n\">sin</span><span class=\"p\">,</span> <span class=\"n\">sqrt</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">3</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">is_meromorphic</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">is_meromorphic</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">is_meromorphic</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">zoo</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">is_meromorphic</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">is_meromorphic</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">is_meromorphic</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">zoo</span><span class=\"p\">)</span>\n<span class=\"go\">False</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">h</span><span class=\"o\">.</span><span class=\"n\">is_meromorphic</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">h</span><span class=\"o\">.</span><span class=\"n\">is_meromorphic</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">h</span><span class=\"o\">.</span><span class=\"n\">is_meromorphic</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">zoo</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n\n<p>Multivalued functions are considered meromorphic when their\nbranches are meromorphic. Thus most functions are meromorphic\neverywhere except at essential singularities and branch points.\nIn particular, they will be meromorphic also on branch cuts\nexcept at their endpoints.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_meromorphic</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_meromorphic</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_meromorphic</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_meromorphic</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"go\">False</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.is_algebraic_expr", "modulename": "mathematics", "qualname": "Expr.is_algebraic_expr", "kind": "function", "doc": "<p>This tests whether a given expression is algebraic or not, in the\ngiven symbols, syms. When syms is not given, all free symbols\nwill be used. The rational function does not have to be in expanded\nor in any kind of canonical form.</p>\n\n<p>This function returns False for expressions that are \"algebraic\nexpressions\" with symbolic exponents. This is a simple extension to the\nis_rational_function, including rational exponentiation.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">Symbol</span><span class=\"p\">,</span> <span class=\"n\">sqrt</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">,</span> <span class=\"n\">real</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_rational_function</span><span class=\"p\">()</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_algebraic_expr</span><span class=\"p\">()</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n\n<p>This function does not attempt any nontrivial simplifications that may\nresult in an expression that does not appear to be an algebraic\nexpression to become one.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">exp</span><span class=\"p\">,</span> <span class=\"n\">factor</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">is_algebraic_expr</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">factor</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_algebraic_expr</span><span class=\"p\">()</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n\n<h1 id=\"see-also\">See Also</h1>\n\n<p>is_rational_function()</p>\n\n<h1 id=\"references\">References</h1>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">syms</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.series", "modulename": "mathematics", "qualname": "Expr.series", "kind": "function", "doc": "<p>Series expansion of \"self\" around <code>x = x0</code> yielding either terms of\nthe series one by one (the lazy series given when n=None), else\nall the terms at once when n != None.</p>\n\n<p>Returns the series expansion of \"self\" around the point <code>x = x0</code>\nwith respect to <code>x</code> up to <code>O((x - x0)**n, x, x0)</code> (default n is 6).</p>\n\n<p>If <code>x=None</code> and <code>self</code> is univariate, the univariate symbol will\nbe supplied, otherwise an error will be raised.</p>\n\n<h1 id=\"parameters\">Parameters</h1>\n\n<p>expr : Expression\n       The expression whose series is to be expanded.</p>\n\n<p>x : Symbol\n    It is the variable of the expression to be calculated.</p>\n\n<p>x0 : Value\n     The value around which <code>x</code> is calculated. Can be any value\n     from <code>-oo</code> to <code>oo</code>.</p>\n\n<p>n : Value\n    The number of terms upto which the series is to be expanded.</p>\n\n<p>dir : String, optional\n      The series-expansion can be bi-directional. If <code>dir=\"+\"</code>,\n      then (x->x0+). If <code>dir=\"-\", then (x-&gt;x0-). For infinite\n</code>x0<code>(</code>oo<code>or</code>-oo<code>), the</code>dir<code>argument is determined\n      from the direction of the infinity (i.e.,</code>dir=\"-\"<code>for\n</code>oo``).</p>\n\n<p>logx : optional\n       It is used to replace any log(x) in the returned series with a\n       symbolic value rather than evaluating the actual value.</p>\n\n<p>cdir : optional\n       It stands for complex direction, and indicates the direction\n       from which the expansion needs to be evaluated.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">cos</span><span class=\"p\">,</span> <span class=\"n\">exp</span><span class=\"p\">,</span> <span class=\"n\">tan</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"p\">()</span>\n<span class=\"go\">1 - x**2/2 + x**4/24 + O(x**6)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"go\">1 - x**2/2 + O(x**4)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">x0</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"go\">cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"go\">cos(x + 1) - y*sin(x + 1) + O(y**2)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"go\">cos(exp(y)) - x*sin(exp(y)) + O(x**2)</span>\n</code></pre>\n</div>\n\n<p>If <code>n=None</code> then a generator of the series terms will be returned.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">term</span><span class=\"o\">=</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">[</span><span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">term</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)]</span>\n<span class=\"go\">[1, -x**2/2]</span>\n</code></pre>\n</div>\n\n<p>For <code>dir=+</code> (default) the series is calculated from the right and\nfor <code>dir=-</code> the series from the left. For smooth functions this\nflag will not alter the results.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"p\">(</span><span class=\"nb\">dir</span><span class=\"o\">=</span><span class=\"s2\">&quot;+&quot;</span><span class=\"p\">)</span>\n<span class=\"go\">x</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"p\">(</span><span class=\"nb\">dir</span><span class=\"o\">=</span><span class=\"s2\">&quot;-&quot;</span><span class=\"p\">)</span>\n<span class=\"go\">-x</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">tan</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"s2\">&quot;+&quot;</span><span class=\"p\">)</span>\n<span class=\"go\">tan(2) + (1 + tan(2)**2)*(x - 2) + (x - 2)**2*(tan(2)**3 + tan(2)) +</span>\n<span class=\"go\">(x - 2)**3*(1/3 + 4*tan(2)**2/3 + tan(2)**4) + (x - 2)**4*(tan(2)**5 +</span>\n<span class=\"go\">5*tan(2)**3/3 + 2*tan(2)/3) + (x - 2)**5*(2/15 + 17*tan(2)**2/15 +</span>\n<span class=\"go\">2*tan(2)**4 + tan(2)**6) + O((x - 2)**6, (x, 2))</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"s2\">&quot;-&quot;</span><span class=\"p\">)</span>\n<span class=\"go\">tan(2) + (2 - x)*(-tan(2)**2 - 1) + (2 - x)**2*(tan(2)**3 + tan(2))</span>\n<span class=\"go\">+ O((x - 2)**3, (x, 2))</span>\n</code></pre>\n</div>\n\n<h1 id=\"returns\">Returns</h1>\n\n<p>Expr : Expression\n    Series expansion of the expression about x0</p>\n\n<h1 id=\"raises\">Raises</h1>\n\n<p>TypeError\n    If \"n\" and \"x0\" are infinity objects</p>\n\n<p>PoleError\n    If \"x0\" is an infinity object</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">x0</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">6</span>, </span><span class=\"param\"><span class=\"nb\">dir</span><span class=\"o\">=</span><span class=\"s1\">&#39;+&#39;</span>, </span><span class=\"param\"><span class=\"n\">logx</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">cdir</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.aseries", "modulename": "mathematics", "qualname": "Expr.aseries", "kind": "function", "doc": "<p>Asymptotic Series expansion of self.\nThis is equivalent to <code>self.series(x, oo, n)</code>.</p>\n\n<h1 id=\"parameters\">Parameters</h1>\n\n<p>self : Expression\n       The expression whose series is to be expanded.</p>\n\n<p>x : Symbol\n    It is the variable of the expression to be calculated.</p>\n\n<p>n : Value\n    The number of terms upto which the series is to be expanded.</p>\n\n<p>hir : Boolean\n      Set this parameter to be True to produce hierarchical series.\n      It stops the recursion at an early level and may provide nicer\n      and more useful results.</p>\n\n<p>bound : Value, Integer\n        Use the <code>bound</code> parameter to give limit on rewriting\n        coefficients in its normalised form.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">sin</span><span class=\"p\">,</span> <span class=\"n\">exp</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">x</span><span class=\"p\">))</span> <span class=\"o\">-</span> <span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"n\">x</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">aseries</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">(1/(24*x**4) - 1/(2*x**2) + 1 + O(x**(-6), (x, oo)))*exp(-x)</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">aseries</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">hir</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">-exp(-2*x)*sin(1/x)/2 + exp(-x)*cos(1/x) + O(exp(-3*x), (x, oo))</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"n\">x</span><span class=\"p\">))</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">aseries</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">exp(exp(x)/(1 - 1/x))</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">aseries</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">bound</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"c1\"># doctest: +SKIP</span>\n<span class=\"go\">exp(exp(x)/x**2)*exp(exp(x)/x)*exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x**2)*exp(exp(x))</span>\n</code></pre>\n</div>\n\n<h1 id=\"returns\">Returns</h1>\n\n<p>Expr\n    Asymptotic series expansion of the expression.</p>\n\n<h1 id=\"notes\">Notes</h1>\n\n<p>This algorithm is directly induced from the limit computational algorithm provided by Gruntz.\nIt majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first\nto look for the most rapidly varying subexpression w of a given expression f and then expands f\nin a series in w. Then same thing is recursively done on the leading coefficient\ntill we get constant coefficients.</p>\n\n<p>If the most rapidly varying subexpression of a given expression f is f itself,\nthe algorithm tries to find a normalised representation of the mrv set and rewrites f\nusing this normalised representation.</p>\n\n<p>If the expansion contains an order term, it will be either <code>O(x ** (-n))</code> or <code>O(w ** (-n))</code>\nwhere <code>w</code> belongs to the most rapidly varying expression of <code>self</code>.</p>\n\n<h1 id=\"references\">References</h1>\n\n<h1 id=\"see-also\">See Also</h1>\n\n<p>Expr.aseries: See the docstring of this function for complete details of this wrapper.</p>\n\n<div class=\"footnotes\">\n<hr />\n<ol>\n</ol>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">6</span>, </span><span class=\"param\"><span class=\"n\">bound</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">hir</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.taylor_term", "modulename": "mathematics", "qualname": "Expr.taylor_term", "kind": "function", "doc": "<p>General method for the taylor term.</p>\n\n<p>This method is slow, because it differentiates n-times. Subclasses can\nredefine it to make it faster by using the \"previous_terms\".</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">previous_terms</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.lseries", "modulename": "mathematics", "qualname": "Expr.lseries", "kind": "function", "doc": "<p>Wrapper for series yielding an iterator of the terms of the series.</p>\n\n<p>Note: an infinite series will yield an infinite iterator. The following,\nfor exaxmple, will never terminate. It will just keep printing terms\nof the sin(x) series::</p>\n\n<p>for term in sin(x).lseries(x):\n      print term</p>\n\n<p>The advantage of lseries() over nseries() is that many times you are\njust interested in the next term in the series (i.e. the first term for\nexample), but you do not know how many you should ask for in nseries()\nusing the \"n\" parameter.</p>\n\n<p>See also nseries().</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">x0</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"nb\">dir</span><span class=\"o\">=</span><span class=\"s1\">&#39;+&#39;</span>, </span><span class=\"param\"><span class=\"n\">logx</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">cdir</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.nseries", "modulename": "mathematics", "qualname": "Expr.nseries", "kind": "function", "doc": "<p>Wrapper to _eval_nseries if assumptions allow, else to series.</p>\n\n<p>If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is\ncalled. This calculates \"n\" terms in the innermost expressions and\nthen builds up the final series just by \"cross-multiplying\" everything\nout.</p>\n\n<p>The optional <code>logx</code> parameter can be used to replace any log(x) in the\nreturned series with a symbolic value to avoid evaluating log(x) at 0. A\nsymbol to use in place of log(x) should be provided.</p>\n\n<p>Advantage -- it's fast, because we do not have to determine how many\nterms we need to calculate in advance.</p>\n\n<p>Disadvantage -- you may end up with less terms than you may have\nexpected, but the O(x**n) term appended will always be correct and\nso the result, though perhaps shorter, will also be correct.</p>\n\n<p>If any of those assumptions is not met, this is treated like a\nwrapper to series which will try harder to return the correct\nnumber of terms.</p>\n\n<p>See also lseries().</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">sin</span><span class=\"p\">,</span> <span class=\"n\">log</span><span class=\"p\">,</span> <span class=\"n\">Symbol</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">nseries</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">)</span>\n<span class=\"go\">x - x**3/6 + x**5/120 + O(x**6)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">nseries</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"go\">x - x**2/2 + x**3/3 - x**4/4 + O(x**5)</span>\n</code></pre>\n</div>\n\n<p>Handling of the <code>logx</code> parameter --- in the following example the\nexpansion fails since <code>sin</code> does not have an asymptotic expansion\nat -oo (the limit of log(x) as x approaches 0):</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">nseries</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">)</span>\n<span class=\"gt\">Traceback (most recent call last):</span>\n<span class=\"c\">...</span>\n<span class=\"gr\">PoleError</span>: <span class=\"n\">...</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">logx</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s1\">&#39;logx&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">nseries</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"n\">logx</span><span class=\"o\">=</span><span class=\"n\">logx</span><span class=\"p\">)</span>\n<span class=\"go\">sin(logx)</span>\n</code></pre>\n</div>\n\n<p>In the following example, the expansion works but gives only an Order term\nunless the <code>logx</code> parameter is used:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"n\">y</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">nseries</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"go\">O(log(x)**2)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">nseries</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">logx</span><span class=\"o\">=</span><span class=\"n\">logx</span><span class=\"p\">)</span>\n<span class=\"go\">exp(logx*y)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">x0</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">6</span>, </span><span class=\"param\"><span class=\"nb\">dir</span><span class=\"o\">=</span><span class=\"s1\">&#39;+&#39;</span>, </span><span class=\"param\"><span class=\"n\">logx</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">cdir</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.limit", "modulename": "mathematics", "qualname": "Expr.limit", "kind": "function", "doc": "<p>Compute limit x->xlim.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">xlim</span>, </span><span class=\"param\"><span class=\"nb\">dir</span><span class=\"o\">=</span><span class=\"s1\">&#39;+&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.compute_leading_term", "modulename": "mathematics", "qualname": "Expr.compute_leading_term", "kind": "function", "doc": "<p>as_leading_term is only allowed for results of .series()\nThis is a wrapper to compute a series first.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">logx</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_leading_term", "modulename": "mathematics", "qualname": "Expr.as_leading_term", "kind": "function", "doc": "<p>Returns the leading (nonzero) term of the series expansion of self.</p>\n\n<p>The _eval_as_leading_term routines are used to do this, and they must\nalways return a non-zero value.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_leading_term</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">1</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_leading_term</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">x**(-2)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">symbols</span>, </span><span class=\"param\"><span class=\"n\">logx</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">cdir</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_coeff_exponent", "modulename": "mathematics", "qualname": "Expr.as_coeff_exponent", "kind": "function", "doc": "<p><code>c*x**e -&gt; c,e</code> where x can be any symbolic expression.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.leadterm", "modulename": "mathematics", "qualname": "Expr.leadterm", "kind": "function", "doc": "<p>Returns the leading term a<em>x</em>*b as a tuple (a, b).</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">x</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">+</span><span class=\"n\">x</span><span class=\"o\">+</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">leadterm</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">(1, 0)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"o\">+</span><span class=\"n\">x</span><span class=\"o\">+</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">leadterm</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"go\">(1, -2)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">logx</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">cdir</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_coeff_Mul", "modulename": "mathematics", "qualname": "Expr.as_coeff_Mul", "kind": "function", "doc": "<p>Efficiently extract the coefficient of a product.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rational</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.as_coeff_Add", "modulename": "mathematics", "qualname": "Expr.as_coeff_Add", "kind": "function", "doc": "<p>Efficiently extract the coefficient of a summation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rational</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.fps", "modulename": "mathematics", "qualname": "Expr.fps", "kind": "function", "doc": "<p>Compute formal power power series of self.</p>\n\n<p>See the docstring of the <code>fps()</code> function in sympy.series.formal for\nmore information.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">x</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">x0</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"nb\">dir</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">hyper</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">4</span>,</span><span class=\"param\">\t<span class=\"n\">rational</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">full</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.fourier_series", "modulename": "mathematics", "qualname": "Expr.fourier_series", "kind": "function", "doc": "<p>Compute fourier sine/cosine series of self.</p>\n\n<p>See the docstring of the <code>fourier_series()</code> in sympy.series.fourier\nfor more information.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">limits</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.diff", "modulename": "mathematics", "qualname": "Expr.diff", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">symbols</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">assumptions</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.expand", "modulename": "mathematics", "qualname": "Expr.expand", "kind": "function", "doc": "<p>Expand an expression using hints.</p>\n\n<p>See the docstring of the expand() function in sympy.core.function for\nmore information.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">deep</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">modulus</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">power_base</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">power_exp</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">mul</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">log</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">multinomial</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">basic</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">hints</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.integrate", "modulename": "mathematics", "qualname": "Expr.integrate", "kind": "function", "doc": "<p>See the integrate function in sympy.integrals</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.nsimplify", "modulename": "mathematics", "qualname": "Expr.nsimplify", "kind": "function", "doc": "<p>See the nsimplify function in sympy.simplify</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">constants</span><span class=\"o\">=</span><span class=\"p\">()</span>, </span><span class=\"param\"><span class=\"n\">tolerance</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">full</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.separate", "modulename": "mathematics", "qualname": "Expr.separate", "kind": "function", "doc": "<p>See the separate function in sympy.simplify</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">deep</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">force</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.collect", "modulename": "mathematics", "qualname": "Expr.collect", "kind": "function", "doc": "<p>See the collect function in sympy.simplify</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">syms</span>,</span><span class=\"param\">\t<span class=\"n\">func</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">evaluate</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">exact</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distribute_order_term</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.together", "modulename": "mathematics", "qualname": "Expr.together", "kind": "function", "doc": "<p>See the together function in sympy.polys</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.apart", "modulename": "mathematics", "qualname": "Expr.apart", "kind": "function", "doc": "<p>See the apart function in sympy.polys</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">args</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.ratsimp", "modulename": "mathematics", "qualname": "Expr.ratsimp", "kind": "function", "doc": "<p>See the ratsimp function in sympy.simplify</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.trigsimp", "modulename": "mathematics", "qualname": "Expr.trigsimp", "kind": "function", "doc": "<p>See the trigsimp function in sympy.simplify</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">args</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.radsimp", "modulename": "mathematics", "qualname": "Expr.radsimp", "kind": "function", "doc": "<p>See the radsimp function in sympy.simplify</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.powsimp", "modulename": "mathematics", "qualname": "Expr.powsimp", "kind": "function", "doc": "<p>See the powsimp function in sympy.simplify</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.combsimp", "modulename": "mathematics", "qualname": "Expr.combsimp", "kind": "function", "doc": "<p>See the combsimp function in sympy.simplify</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.gammasimp", "modulename": "mathematics", "qualname": "Expr.gammasimp", "kind": "function", "doc": "<p>See the gammasimp function in sympy.simplify</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.factor", "modulename": "mathematics", "qualname": "Expr.factor", "kind": "function", "doc": "<p>See the factor() function in sympy.polys.polytools</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">gens</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">args</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.cancel", "modulename": "mathematics", "qualname": "Expr.cancel", "kind": "function", "doc": "<p>See the cancel function in sympy.polys</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">gens</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">args</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.invert", "modulename": "mathematics", "qualname": "Expr.invert", "kind": "function", "doc": "<p>Return the multiplicative inverse of <code>self</code> mod <code>g</code>\nwhere <code>self</code> (and <code>g</code>) may be symbolic expressions).</p>\n\n<h1 id=\"see-also\">See Also</h1>\n\n<p>sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">g</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">gens</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">args</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.Expr.round", "modulename": "mathematics", "qualname": "Expr.round", "kind": "function", "doc": "<p>Return x rounded to the given decimal place.</p>\n\n<p>If a complex number would results, apply round to the real\nand imaginary components of the number.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">pi</span><span class=\"p\">,</span> <span class=\"n\">E</span><span class=\"p\">,</span> <span class=\"n\">I</span><span class=\"p\">,</span> <span class=\"n\">S</span><span class=\"p\">,</span> <span class=\"n\">Number</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pi</span><span class=\"o\">.</span><span class=\"n\">round</span><span class=\"p\">()</span>\n<span class=\"go\">3</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pi</span><span class=\"o\">.</span><span class=\"n\">round</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"go\">3.14</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">pi</span> <span class=\"o\">+</span> <span class=\"n\">E</span><span class=\"o\">*</span><span class=\"n\">I</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">round</span><span class=\"p\">()</span>\n<span class=\"go\">6 + 3*I</span>\n</code></pre>\n</div>\n\n<p>The round method has a chopping effect:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">pi</span> <span class=\"o\">+</span> <span class=\"n\">I</span><span class=\"o\">/</span><span class=\"mi\">10</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">round</span><span class=\"p\">()</span>\n<span class=\"go\">6</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">pi</span><span class=\"o\">/</span><span class=\"mi\">10</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">I</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">round</span><span class=\"p\">()</span>\n<span class=\"go\">2*I</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">pi</span><span class=\"o\">/</span><span class=\"mi\">10</span> <span class=\"o\">+</span> <span class=\"n\">E</span><span class=\"o\">*</span><span class=\"n\">I</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">round</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"go\">0.31 + 2.72*I</span>\n</code></pre>\n</div>\n\n<h1 id=\"notes\">Notes</h1>\n\n<p>The Python <code>round</code> function uses the SymPy <code>round</code> method so it\nwill always return a SymPy number (not a Python float or int):</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"nb\">round</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">(</span><span class=\"mi\">123</span><span class=\"p\">),</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"n\">Number</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mathematics.energy", "modulename": "mathematics", "qualname": "energy", "kind": "function", "doc": "<p>energy(indices)</p>\n\n<p>Returns the sum M(m) of operator sequence indices.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>indices</strong>: Operator sequence indices.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Union[int, float, Fraction, complex, Expr]</strong>: Sum M(m).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">indices</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">E</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"o\">~</span><span class=\"n\">E</span>:</span></span>", "funcdef": "def"}, {"fullname": "mathematics.energy_broad", "modulename": "mathematics", "qualname": "energy_broad", "kind": "function", "doc": "<p>energy_broad(indices)</p>\n\n<p>Returns the <em>broadened</em> sum M(m)*theta(|M(m)|-delta) of operator sequence indices, where theta is the Heaviside\nstep function.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>indices</strong>: Operator sequence indices.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Union[int, float, Fraction]</strong>: Sum M(m)*theta(|M(m)|-delta).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">indices</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">delta</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "mathematics.signum", "modulename": "mathematics", "qualname": "signum", "kind": "function", "doc": "<p>signum(indices1, indices2)</p>\n\n<p>Returns the prefactor sgn(M(m1)) - sgn(M(m2)).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>indices1</strong>: Operator sequence indices whose sgn(M(m1)) is to be added.</li>\n<li><strong>indices2</strong>: Operator sequence indices whose sgn(M(m2)) is to be substracted.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>int</strong>: Difference of signum functions.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">indices1</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">indices2</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "mathematics.signum_broad", "modulename": "mathematics", "qualname": "signum_broad", "kind": "function", "doc": "<p>signum_broad(indices1, indices2, delta)</p>\n\n<p>Returns the prefactor sgn_<code>delta</code>(M(m1)) - sgn_delta(M(m2)), where sgn_d is the broadened signum function with\nsgn_d(x) = 0 for |x| &lt;= d and sgn_d(x) = sgn(x), otherwise.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>indices1</strong>: Operator sequence indices whose sgn_d(M(m1)) is to be added.</li>\n<li><strong>indices2</strong>: Operator sequence indices whose sgn_d(M(m2)) is to be substracted.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>int</strong>: Difference of broad signum functions.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">indices1</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">indices2</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">delta</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "mathematics.signum_complex", "modulename": "mathematics", "qualname": "signum_complex", "kind": "function", "doc": "<p>signum_complex(indices1, indices2)</p>\n\n<p>Returns the prefactor sgn(M(m1)) - sgn(M(m2)) with the definition sgn(z) = z / |z| as used in the Schmiedinghoff,\nUhrig paper.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>indices1</strong>: Operator sequence indices whose complex sgn(M(m1)) is to be added.</li>\n<li><strong>indices2</strong>: Operator sequence indices whose complex sgn(M(m2)) is to be subtracted.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Union[complex, Expr]</strong>: Difference of complex signum functions.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">indices1</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">indices2</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "mathematics.exponential", "modulename": "mathematics", "qualname": "exponential", "kind": "function", "doc": "<p>exponential(indices, indices1, indices2)</p>\n\n<p>Returns the exponential exp(- alpha x) with alpha = - (|M(m)| - |M(m1)| - |M(m2)|).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>indices</strong>: Operator sequence indices whose |M(m)| is to be added in the exponential.</li>\n<li><strong>indices1</strong>: First operator sequence indices whose |M(m1)| is to be subtracted in the exponential.</li>\n<li><strong>indices2</strong>: Second operator sequence indices whose |M(m2)| is to be subtracted in the exponential.</li>\n<li><strong>energy_func</strong>: Energy function to be used (normal or broad).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>QuasiPolynomial</strong>: Resulting quasi-polynomial.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">indices</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">indices1</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">indices2</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">energy_func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]],</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">QuasiPolynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "mathematics.partitions", "modulename": "mathematics", "qualname": "partitions", "kind": "function", "doc": "<p>partitions(sequence)</p>\n\n<p>Returns all partitions of the operator sequence (m, n, o, ...) into ((m1, n1, o1, ...), (m2, n2, o2, ...)).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>sequence</strong>: Operator sequence to be partitioned.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>List[Tuple[Tuple[Tuple[int,...],...],Tuple[Tuple[int,...],...]]]</strong>: List of partitions.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sequence</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial", "modulename": "quasiPolynomial", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "quasiPolynomial.is_zero", "modulename": "quasiPolynomial", "qualname": "is_zero", "kind": "function", "doc": "<p>is_zero(scalar)</p>\n\n<p>Checks for exact numbers whether they are equal to zero and for floats whether they are close to zero.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>scalar</strong>: Number to be compared to zero.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bool</strong>: <code>True</code> if number is zero (exact numbers) or close to zero (floats).</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>TypeError</strong>: If number is not of type scalar.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">scalar</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.are_close", "modulename": "quasiPolynomial", "qualname": "are_close", "kind": "function", "doc": "<p>are_close(scalar1, scalar2)</p>\n\n<p>Checks for non-zero exact numbers whether they are equal and for non-zero floats whether they are close.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>scalar1</strong>: First number to be compared.</li>\n<li><strong>scalar2</strong>: Second number to be compared.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bool</strong>: <code>True</code> if numbers are equal (exact) or close (floats).</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>TypeError</strong>: If numbers are not of type scalar.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">scalar1</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">scalar2</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.inverse", "modulename": "quasiPolynomial", "qualname": "inverse", "kind": "function", "doc": "<p>inverse(scalar)</p>\n\n<p>Inverts number either exactly or approximately.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>scalar</strong>: Number to be inverted.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Union[int, float, Fraction, complex, Expr]</strong>: Inverted number.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">scalar</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.pretty_factor_print", "modulename": "quasiPolynomial", "qualname": "pretty_factor_print", "kind": "function", "doc": "<p>pretty_factor_print(coeff)</p>\n\n<p>Returns a coefficient into a form suitable to be read by humans.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>coeff</strong> (Union[int, float, Fraction, complex, Expr]):\nCoefficient to be printed.</li>\n<li><strong>leave1</strong> (bool):\nIf <code>True</code> a coefficient of <code>1</code> or <code>-1</code> will not be simplified.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Human-readable form of the coefficient.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">coeff</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">leave1</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.Polynomial", "modulename": "quasiPolynomial", "qualname": "Polynomial", "kind": "class", "doc": "<p>Polynomial(coefficient_dict)</p>\n\n<p>A class used to represent a polynomial.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>coefficient_list</strong> (List[Union[int, float, Fraction, complex, Expr]]):\nThe list of coefficients.\nThe coefficient of x^n is coefficient_array[n].</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>__private_coefficients</strong> (np.ndarray[Union[int, float, Fraction, complex, Expr]]):\nThe numpy array of coefficients.\nThe coefficient of x^n is __private_coefficients[n].</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">Polynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]))</span>\n<span class=\"go\">[&#39;1&#39;, &#39;2&#39;]</span>\n</code></pre>\n</div>\n\n<p>Prints the coefficient array.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Polynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span> <span class=\"o\">==</span> <span class=\"n\">Polynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">])</span>\n<span class=\"go\">False</span>\n</code></pre>\n</div>\n\n<p>Checks whether two polynomials are mathematically equal.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"o\">-</span><span class=\"n\">Polynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n\n<p>Multiplies a polynomial with -1.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Polynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span> <span class=\"o\">+</span> <span class=\"n\">Polynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n\n<p>Adds two polynomials.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Polynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span> <span class=\"o\">-</span> <span class=\"n\">Polynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n\n<p>Subtracts a polynomial from another.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Polynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span> <span class=\"o\">*</span> <span class=\"n\">Polynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n\n<p>Multiplies two polynomials.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Polynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span> <span class=\"o\">*</span> <span class=\"mi\">3</span>\n</code></pre>\n</div>\n\n<p>Multiplies a polynomial with a scalar.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"mi\">3</span> <span class=\"o\">*</span> <span class=\"n\">Polynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n\n<p>Multiplies a scalar with a polynomial.</p>\n"}, {"fullname": "quasiPolynomial.Polynomial.__init__", "modulename": "quasiPolynomial", "qualname": "Polynomial.__init__", "kind": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>coefficient_list</strong> (List[Union[int, float, Fraction, complex, Expr]]):\nThe list of coefficients.\nThe coefficient of x^n is coefficient_dict[n].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">coefficient_list</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "quasiPolynomial.Polynomial.coefficients", "modulename": "quasiPolynomial", "qualname": "Polynomial.coefficients", "kind": "function", "doc": "<p>p.coefficients()</p>\n\n<p>Gets the coefficient array.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray[Union[int, float, Fraction, complex, Expr]]</strong>: Coefficient array.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.Polynomial.zero", "modulename": "quasiPolynomial", "qualname": "Polynomial.zero", "kind": "function", "doc": "<p>Polynomial.zero()</p>\n\n<p>Creates an empty polynomial.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Polynomial</strong>: Empty polynomial.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">Polynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.Polynomial.simplify", "modulename": "quasiPolynomial", "qualname": "Polynomial.simplify", "kind": "function", "doc": "<p>p.simplify()</p>\n\n<p>Simplifies a polynomial by <em>removing</em> zeros.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Polynomial</strong>: Simplified polynomial without redundant zeros.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">Polynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.Polynomial.new", "modulename": "quasiPolynomial", "qualname": "Polynomial.new", "kind": "function", "doc": "<p>new(List[scalar])</p>\n\n<p>Creates a quasi-polynomial using a list of __private_coefficients.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>coefficient_list</strong>: List of __private_coefficients.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Polynomial</strong>: Created polynomial.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>TypeError</strong>: If coefficients are not of type scalar.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">coefficient_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">Polynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.Polynomial.copy", "modulename": "quasiPolynomial", "qualname": "Polynomial.copy", "kind": "function", "doc": "<p>p.copy()</p>\n\n<p>Copies a polynomial.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Polynomial</strong>: Copy of polynomial.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">Polynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.Polynomial.pretty_print", "modulename": "quasiPolynomial", "qualname": "Polynomial.pretty_print", "kind": "function", "doc": "<p>p.pretty_print()</p>\n\n<p>Transform a polynomial in the mathematical form suitable to be read by humans.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Human-readable form of polynomial.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.Polynomial.scalar_multiplication", "modulename": "quasiPolynomial", "qualname": "Polynomial.scalar_multiplication", "kind": "function", "doc": "<p>p.scalar_multiplication(scalar)</p>\n\n<p>Multiplies a polynomial with a scalar.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>scalar</strong>: Scalar to be multiplied with <code>self</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Polynomial</strong>: Resulting polynomial after multiplication.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">scalar</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">Polynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.Polynomial.integrate", "modulename": "quasiPolynomial", "qualname": "Polynomial.integrate", "kind": "function", "doc": "<p>integrate(p)</p>\n\n<p>Integrate a polynomial with starting condition 0.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Polynomial</strong>: Resulting polynomial after integration.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">Polynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.Polynomial.diff", "modulename": "quasiPolynomial", "qualname": "Polynomial.diff", "kind": "function", "doc": "<p>diff(p)</p>\n\n<p>Perform the derivative of a polynomial.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Polynomial</strong>: Resulting polynomial after differentiation.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">Polynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.Polynomial.get_constant", "modulename": "quasiPolynomial", "qualname": "Polynomial.get_constant", "kind": "function", "doc": "<p>p.get_constant()</p>\n\n<p>Returns the constant coefficient.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Union[int, float, Fraction, complex, Expr]</strong>: Constant coefficient.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.QuasiPolynomial", "modulename": "quasiPolynomial", "qualname": "QuasiPolynomial", "kind": "class", "doc": "<p>QuasiPolynomial(coefficient_dict)</p>\n\n<p>A class used to represent a quasi-polynomial.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>polynomial_dict</strong> (Dict[Union[int, float, Fraction, Expr], Polynomial]):\nThe dictionary containing all polynomials.\nThe coefficient polynomial of exp(- alpha x) is polynomial_dict[alpha].</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>polynomial_dict</strong> (Dict[Union[int, float, Fraction, Expr], Polynomial]):\nThe dictionary containing all polynomials.\nThe coefficient polynomial of exp(- alpha x) is polynomial[alpha].</li>\n<li><strong>polynomials</strong> (List[Tuple[Union[int, float, Fraction, Expr], Polynomial]]):\nThe list containing tuples of all exponents and their polynomials.</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">QuasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">({</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]}))</span>\n<span class=\"go\">[(0, [&#39;1&#39;, &#39;2&#39;]), (3, [&#39;4&#39;, &#39;5&#39;])]</span>\n</code></pre>\n</div>\n\n<p>Prints the coefficients.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">QuasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">({</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]})</span> <span class=\"o\">==</span> <span class=\"n\">QuasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">({</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">]})</span>\n<span class=\"go\">False</span>\n</code></pre>\n</div>\n\n<p>Checks whether two quasi-polynomials are mathematically equal.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"o\">-</span><span class=\"n\">QuasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">({</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]})</span>\n</code></pre>\n</div>\n\n<p>Multiplies a quasi-polynomial with -1.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">QuasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">({</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]})</span> <span class=\"o\">+</span> <span class=\"n\">QuasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">({</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">]})</span>\n</code></pre>\n</div>\n\n<p>Adds two quasi-polynomials.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">QuasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">({</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]})</span> <span class=\"o\">-</span> <span class=\"n\">QuasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">({</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">]})</span>\n</code></pre>\n</div>\n\n<p>Subtracts a quasi-polynomial from another.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">QuasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">({</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]})</span> <span class=\"o\">*</span> <span class=\"n\">QuasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">({</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">]})</span>\n</code></pre>\n</div>\n\n<p>Multiplies two quasi-polynomials.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">QuasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">({</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]})</span> <span class=\"o\">*</span> <span class=\"n\">Polynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n\n<p>Multiplies a quasi-polynomial with a polynomial.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">QuasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">({</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]})</span> <span class=\"o\">*</span> <span class=\"mi\">3</span>\n</code></pre>\n</div>\n\n<p>Multiplies a quasi-polynomial with a scalar.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Polynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span> <span class=\"o\">*</span> <span class=\"n\">QuasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">({</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]})</span>\n</code></pre>\n</div>\n\n<p>Multiplies a polynomial with a quasi-polynomial.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"mi\">3</span> <span class=\"o\">*</span> <span class=\"n\">QuasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">({</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]})</span>\n</code></pre>\n</div>\n\n<p>Multiplies a scalar with a quasi-polynomial.</p>\n"}, {"fullname": "quasiPolynomial.QuasiPolynomial.__init__", "modulename": "quasiPolynomial", "qualname": "QuasiPolynomial.__init__", "kind": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>polynomial_dict</strong> (Dict[Union[int, float, Fraction, Expr], Polynomial]):\nThe dictionary containing all polynomials.\nThe coefficient polynomial of exp(- alpha x) is polynomial_dict[alpha].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">polynomial_dict</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">],</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">Polynomial</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "quasiPolynomial.QuasiPolynomial.sort", "modulename": "quasiPolynomial", "qualname": "QuasiPolynomial.sort", "kind": "function", "doc": "<p>qp.sort()</p>\n\n<p>Sorts a quasi-polynomial by exponent alpha.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>QuasiPolynomial</strong>: Sorted quasi-polynomial.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">QuasiPolynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.QuasiPolynomial.zero", "modulename": "quasiPolynomial", "qualname": "QuasiPolynomial.zero", "kind": "function", "doc": "<p>QuasiPolynomial.zero()</p>\n\n<p>Creates an empty quasi-polynomial.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>QuasiPolynomial</strong>: Empty quasi-polynomial.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">QuasiPolynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.QuasiPolynomial.simplify", "modulename": "quasiPolynomial", "qualname": "QuasiPolynomial.simplify", "kind": "function", "doc": "<p>qp.simplify()</p>\n\n<p>Simplifies a quasi-polynomial by <em>removing</em> zero polynomials.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>QuasiPolynomial</strong>: Simplified quasi-polynomial without redundant zero polynomials.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">QuasiPolynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.QuasiPolynomial.new_integer", "modulename": "quasiPolynomial", "qualname": "QuasiPolynomial.new_integer", "kind": "function", "doc": "<p>new_integer(List[List[scalar]])</p>\n\n<p>Creates a quasi-polynomial with integer exponents using a nested list of __private_coefficients.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>coefficient_list</strong>: List of __private_coefficients corresponsing to integer exponent.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>QuasiPolynomial</strong>: Created quasi-polynomial.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">coefficient_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">QuasiPolynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.QuasiPolynomial.new", "modulename": "quasiPolynomial", "qualname": "QuasiPolynomial.new", "kind": "function", "doc": "<p>new(Dict[scalar, List[scalar]])</p>\n\n<p>Creates a quasi-polynomial using a nested list of (exponential, __private_coefficients).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>coefficient_dict</strong>: Nested list of exponentials and __private_coefficients.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>QuasiPolynomial</strong>: Created polynomials.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">coefficient_dict</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">],</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">QuasiPolynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.QuasiPolynomial.copy", "modulename": "quasiPolynomial", "qualname": "QuasiPolynomial.copy", "kind": "function", "doc": "<p>copy(p)</p>\n\n<p>Copies a quasi-polynomial.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>quasi-Polynomial</strong>: Copy of quasi-polynomial.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">QuasiPolynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.QuasiPolynomial.pretty_print", "modulename": "quasiPolynomial", "qualname": "QuasiPolynomial.pretty_print", "kind": "function", "doc": "<p>qp.pretty_print()</p>\n\n<p>Transform a quasi-polynomial in the mathematical form suitable to be read by humans.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Human-readable form of quasi-polynomial.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.QuasiPolynomial.scalar_multiplication", "modulename": "quasiPolynomial", "qualname": "QuasiPolynomial.scalar_multiplication", "kind": "function", "doc": "<p>qp.scalar_multiplication(scalar)</p>\n\n<p>Multiplies a quasi-polynomial with a scalar.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>scalar</strong>: Scalar to be multiplied with <code>self</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>QuasiPolynomial</strong>: Resulting quasi-polynomial after multiplication.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">scalar</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">QuasiPolynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.QuasiPolynomial.integrate", "modulename": "quasiPolynomial", "qualname": "QuasiPolynomial.integrate", "kind": "function", "doc": "<p>integrate(qp)</p>\n\n<p>Integrate a polynomial with starting condition 0.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>QuasiPolynomial</strong>: Resulting quasi-polynomial after integration.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">quasiPolynomial</span><span class=\"o\">.</span><span class=\"n\">QuasiPolynomial</span>:</span></span>", "funcdef": "def"}, {"fullname": "quasiPolynomial.QuasiPolynomial.get_constant", "modulename": "quasiPolynomial", "qualname": "QuasiPolynomial.get_constant", "kind": "function", "doc": "<p>qp.get_constant()</p>\n\n<p>Returns the constant coefficient of the constant polynomial (alpha = 0).</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Union[int, float, Fraction, complex, Expr]</strong>: Constant coefficient.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">fractions</span><span class=\"o\">.</span><span class=\"n\">Fraction</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();